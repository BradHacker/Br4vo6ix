// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/BradHacker/chungus/ent/heartbeat"
	"github.com/BradHacker/chungus/ent/implant"
	"github.com/BradHacker/chungus/ent/predicate"
	"github.com/BradHacker/chungus/ent/task"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeHeartbeat = "Heartbeat"
	TypeImplant   = "Implant"
	TypeTask      = "Task"
)

// HeartbeatMutation represents an operation that mutates the Heartbeat nodes in the graph.
type HeartbeatMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *string
	ip             *string
	port           *int
	addport        *int
	pid            *int
	addpid         *int
	created_at     *time.Time
	clearedFields  map[string]struct{}
	implant        *int
	clearedimplant bool
	done           bool
	oldValue       func(context.Context) (*Heartbeat, error)
	predicates     []predicate.Heartbeat
}

var _ ent.Mutation = (*HeartbeatMutation)(nil)

// heartbeatOption allows management of the mutation configuration using functional options.
type heartbeatOption func(*HeartbeatMutation)

// newHeartbeatMutation creates new mutation for the Heartbeat entity.
func newHeartbeatMutation(c config, op Op, opts ...heartbeatOption) *HeartbeatMutation {
	m := &HeartbeatMutation{
		config:        c,
		op:            op,
		typ:           TypeHeartbeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHeartbeatID sets the ID field of the mutation.
func withHeartbeatID(id int) heartbeatOption {
	return func(m *HeartbeatMutation) {
		var (
			err   error
			once  sync.Once
			value *Heartbeat
		)
		m.oldValue = func(ctx context.Context) (*Heartbeat, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Heartbeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHeartbeat sets the old Heartbeat of the mutation.
func withHeartbeat(node *Heartbeat) heartbeatOption {
	return func(m *HeartbeatMutation) {
		m.oldValue = func(context.Context) (*Heartbeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HeartbeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HeartbeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HeartbeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *HeartbeatMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *HeartbeatMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *HeartbeatMutation) ResetUUID() {
	m.uuid = nil
}

// SetIP sets the "ip" field.
func (m *HeartbeatMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *HeartbeatMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *HeartbeatMutation) ResetIP() {
	m.ip = nil
}

// SetPort sets the "port" field.
func (m *HeartbeatMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *HeartbeatMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *HeartbeatMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *HeartbeatMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *HeartbeatMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetPid sets the "pid" field.
func (m *HeartbeatMutation) SetPid(i int) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *HeartbeatMutation) Pid() (r int, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *HeartbeatMutation) AddPid(i int) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *HeartbeatMutation) AddedPid() (r int, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *HeartbeatMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HeartbeatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HeartbeatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HeartbeatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetImplantID sets the "implant" edge to the Implant entity by id.
func (m *HeartbeatMutation) SetImplantID(id int) {
	m.implant = &id
}

// ClearImplant clears the "implant" edge to the Implant entity.
func (m *HeartbeatMutation) ClearImplant() {
	m.clearedimplant = true
}

// ImplantCleared reports if the "implant" edge to the Implant entity was cleared.
func (m *HeartbeatMutation) ImplantCleared() bool {
	return m.clearedimplant
}

// ImplantID returns the "implant" edge ID in the mutation.
func (m *HeartbeatMutation) ImplantID() (id int, exists bool) {
	if m.implant != nil {
		return *m.implant, true
	}
	return
}

// ImplantIDs returns the "implant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImplantID instead. It exists only for internal usage by the builders.
func (m *HeartbeatMutation) ImplantIDs() (ids []int) {
	if id := m.implant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImplant resets all changes to the "implant" edge.
func (m *HeartbeatMutation) ResetImplant() {
	m.implant = nil
	m.clearedimplant = false
}

// Where appends a list predicates to the HeartbeatMutation builder.
func (m *HeartbeatMutation) Where(ps ...predicate.Heartbeat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HeartbeatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Heartbeat).
func (m *HeartbeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HeartbeatMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, heartbeat.FieldUUID)
	}
	if m.ip != nil {
		fields = append(fields, heartbeat.FieldIP)
	}
	if m.port != nil {
		fields = append(fields, heartbeat.FieldPort)
	}
	if m.pid != nil {
		fields = append(fields, heartbeat.FieldPid)
	}
	if m.created_at != nil {
		fields = append(fields, heartbeat.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HeartbeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case heartbeat.FieldUUID:
		return m.UUID()
	case heartbeat.FieldIP:
		return m.IP()
	case heartbeat.FieldPort:
		return m.Port()
	case heartbeat.FieldPid:
		return m.Pid()
	case heartbeat.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HeartbeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case heartbeat.FieldUUID:
		return m.OldUUID(ctx)
	case heartbeat.FieldIP:
		return m.OldIP(ctx)
	case heartbeat.FieldPort:
		return m.OldPort(ctx)
	case heartbeat.FieldPid:
		return m.OldPid(ctx)
	case heartbeat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Heartbeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeartbeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case heartbeat.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case heartbeat.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case heartbeat.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case heartbeat.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case heartbeat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Heartbeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HeartbeatMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, heartbeat.FieldPort)
	}
	if m.addpid != nil {
		fields = append(fields, heartbeat.FieldPid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HeartbeatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case heartbeat.FieldPort:
		return m.AddedPort()
	case heartbeat.FieldPid:
		return m.AddedPid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeartbeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case heartbeat.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case heartbeat.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	}
	return fmt.Errorf("unknown Heartbeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HeartbeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HeartbeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HeartbeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Heartbeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HeartbeatMutation) ResetField(name string) error {
	switch name {
	case heartbeat.FieldUUID:
		m.ResetUUID()
		return nil
	case heartbeat.FieldIP:
		m.ResetIP()
		return nil
	case heartbeat.FieldPort:
		m.ResetPort()
		return nil
	case heartbeat.FieldPid:
		m.ResetPid()
		return nil
	case heartbeat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HeartbeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.implant != nil {
		edges = append(edges, heartbeat.EdgeImplant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HeartbeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case heartbeat.EdgeImplant:
		if id := m.implant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HeartbeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HeartbeatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HeartbeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimplant {
		edges = append(edges, heartbeat.EdgeImplant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HeartbeatMutation) EdgeCleared(name string) bool {
	switch name {
	case heartbeat.EdgeImplant:
		return m.clearedimplant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HeartbeatMutation) ClearEdge(name string) error {
	switch name {
	case heartbeat.EdgeImplant:
		m.ClearImplant()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HeartbeatMutation) ResetEdge(name string) error {
	switch name {
	case heartbeat.EdgeImplant:
		m.ResetImplant()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat edge %s", name)
}

// ImplantMutation represents an operation that mutates the Implant nodes in the graph.
type ImplantMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	machine_id        *string
	last_seen_at      *time.Time
	clearedFields     map[string]struct{}
	heartbeats        map[int]struct{}
	removedheartbeats map[int]struct{}
	clearedheartbeats bool
	tasks             map[int]struct{}
	removedtasks      map[int]struct{}
	clearedtasks      bool
	done              bool
	oldValue          func(context.Context) (*Implant, error)
	predicates        []predicate.Implant
}

var _ ent.Mutation = (*ImplantMutation)(nil)

// implantOption allows management of the mutation configuration using functional options.
type implantOption func(*ImplantMutation)

// newImplantMutation creates new mutation for the Implant entity.
func newImplantMutation(c config, op Op, opts ...implantOption) *ImplantMutation {
	m := &ImplantMutation{
		config:        c,
		op:            op,
		typ:           TypeImplant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImplantID sets the ID field of the mutation.
func withImplantID(id int) implantOption {
	return func(m *ImplantMutation) {
		var (
			err   error
			once  sync.Once
			value *Implant
		)
		m.oldValue = func(ctx context.Context) (*Implant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Implant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImplant sets the old Implant of the mutation.
func withImplant(node *Implant) implantOption {
	return func(m *ImplantMutation) {
		m.oldValue = func(context.Context) (*Implant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImplantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImplantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImplantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ImplantMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ImplantMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Implant entity.
// If the Implant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ImplantMutation) ResetUUID() {
	m.uuid = nil
}

// SetMachineID sets the "machine_id" field.
func (m *ImplantMutation) SetMachineID(s string) {
	m.machine_id = &s
}

// MachineID returns the value of the "machine_id" field in the mutation.
func (m *ImplantMutation) MachineID() (r string, exists bool) {
	v := m.machine_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineID returns the old "machine_id" field's value of the Implant entity.
// If the Implant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantMutation) OldMachineID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMachineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMachineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineID: %w", err)
	}
	return oldValue.MachineID, nil
}

// ResetMachineID resets all changes to the "machine_id" field.
func (m *ImplantMutation) ResetMachineID() {
	m.machine_id = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *ImplantMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *ImplantMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the Implant entity.
// If the Implant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *ImplantMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// AddHeartbeatIDs adds the "heartbeats" edge to the Heartbeat entity by ids.
func (m *ImplantMutation) AddHeartbeatIDs(ids ...int) {
	if m.heartbeats == nil {
		m.heartbeats = make(map[int]struct{})
	}
	for i := range ids {
		m.heartbeats[ids[i]] = struct{}{}
	}
}

// ClearHeartbeats clears the "heartbeats" edge to the Heartbeat entity.
func (m *ImplantMutation) ClearHeartbeats() {
	m.clearedheartbeats = true
}

// HeartbeatsCleared reports if the "heartbeats" edge to the Heartbeat entity was cleared.
func (m *ImplantMutation) HeartbeatsCleared() bool {
	return m.clearedheartbeats
}

// RemoveHeartbeatIDs removes the "heartbeats" edge to the Heartbeat entity by IDs.
func (m *ImplantMutation) RemoveHeartbeatIDs(ids ...int) {
	if m.removedheartbeats == nil {
		m.removedheartbeats = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.heartbeats, ids[i])
		m.removedheartbeats[ids[i]] = struct{}{}
	}
}

// RemovedHeartbeats returns the removed IDs of the "heartbeats" edge to the Heartbeat entity.
func (m *ImplantMutation) RemovedHeartbeatsIDs() (ids []int) {
	for id := range m.removedheartbeats {
		ids = append(ids, id)
	}
	return
}

// HeartbeatsIDs returns the "heartbeats" edge IDs in the mutation.
func (m *ImplantMutation) HeartbeatsIDs() (ids []int) {
	for id := range m.heartbeats {
		ids = append(ids, id)
	}
	return
}

// ResetHeartbeats resets all changes to the "heartbeats" edge.
func (m *ImplantMutation) ResetHeartbeats() {
	m.heartbeats = nil
	m.clearedheartbeats = false
	m.removedheartbeats = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ImplantMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ImplantMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ImplantMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ImplantMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ImplantMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ImplantMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ImplantMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the ImplantMutation builder.
func (m *ImplantMutation) Where(ps ...predicate.Implant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImplantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Implant).
func (m *ImplantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImplantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, implant.FieldUUID)
	}
	if m.machine_id != nil {
		fields = append(fields, implant.FieldMachineID)
	}
	if m.last_seen_at != nil {
		fields = append(fields, implant.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImplantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case implant.FieldUUID:
		return m.UUID()
	case implant.FieldMachineID:
		return m.MachineID()
	case implant.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImplantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case implant.FieldUUID:
		return m.OldUUID(ctx)
	case implant.FieldMachineID:
		return m.OldMachineID(ctx)
	case implant.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown Implant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case implant.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case implant.FieldMachineID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineID(v)
		return nil
	case implant.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown Implant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImplantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImplantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Implant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImplantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImplantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImplantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Implant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImplantMutation) ResetField(name string) error {
	switch name {
	case implant.FieldUUID:
		m.ResetUUID()
		return nil
	case implant.FieldMachineID:
		m.ResetMachineID()
		return nil
	case implant.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown Implant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImplantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.heartbeats != nil {
		edges = append(edges, implant.EdgeHeartbeats)
	}
	if m.tasks != nil {
		edges = append(edges, implant.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImplantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case implant.EdgeHeartbeats:
		ids := make([]ent.Value, 0, len(m.heartbeats))
		for id := range m.heartbeats {
			ids = append(ids, id)
		}
		return ids
	case implant.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImplantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedheartbeats != nil {
		edges = append(edges, implant.EdgeHeartbeats)
	}
	if m.removedtasks != nil {
		edges = append(edges, implant.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImplantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case implant.EdgeHeartbeats:
		ids := make([]ent.Value, 0, len(m.removedheartbeats))
		for id := range m.removedheartbeats {
			ids = append(ids, id)
		}
		return ids
	case implant.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImplantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedheartbeats {
		edges = append(edges, implant.EdgeHeartbeats)
	}
	if m.clearedtasks {
		edges = append(edges, implant.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImplantMutation) EdgeCleared(name string) bool {
	switch name {
	case implant.EdgeHeartbeats:
		return m.clearedheartbeats
	case implant.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImplantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Implant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImplantMutation) ResetEdge(name string) error {
	switch name {
	case implant.EdgeHeartbeats:
		m.ResetHeartbeats()
		return nil
	case implant.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Implant edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *string
	_type          *task.Type
	payload        *string
	stdout         *string
	stderr         *string
	has_run        *bool
	created_at     *time.Time
	clearedFields  map[string]struct{}
	implant        *int
	clearedimplant bool
	done           bool
	oldValue       func(context.Context) (*Task, error)
	predicates     []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TaskMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TaskMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TaskMutation) ResetUUID() {
	m.uuid = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(t task.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v task.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetPayload sets the "payload" field.
func (m *TaskMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *TaskMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *TaskMutation) ResetPayload() {
	m.payload = nil
}

// SetStdout sets the "stdout" field.
func (m *TaskMutation) SetStdout(s string) {
	m.stdout = &s
}

// Stdout returns the value of the "stdout" field in the mutation.
func (m *TaskMutation) Stdout() (r string, exists bool) {
	v := m.stdout
	if v == nil {
		return
	}
	return *v, true
}

// OldStdout returns the old "stdout" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStdout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStdout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStdout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdout: %w", err)
	}
	return oldValue.Stdout, nil
}

// ResetStdout resets all changes to the "stdout" field.
func (m *TaskMutation) ResetStdout() {
	m.stdout = nil
}

// SetStderr sets the "stderr" field.
func (m *TaskMutation) SetStderr(s string) {
	m.stderr = &s
}

// Stderr returns the value of the "stderr" field in the mutation.
func (m *TaskMutation) Stderr() (r string, exists bool) {
	v := m.stderr
	if v == nil {
		return
	}
	return *v, true
}

// OldStderr returns the old "stderr" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStderr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStderr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStderr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderr: %w", err)
	}
	return oldValue.Stderr, nil
}

// ResetStderr resets all changes to the "stderr" field.
func (m *TaskMutation) ResetStderr() {
	m.stderr = nil
}

// SetHasRun sets the "has_run" field.
func (m *TaskMutation) SetHasRun(b bool) {
	m.has_run = &b
}

// HasRun returns the value of the "has_run" field in the mutation.
func (m *TaskMutation) HasRun() (r bool, exists bool) {
	v := m.has_run
	if v == nil {
		return
	}
	return *v, true
}

// OldHasRun returns the old "has_run" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldHasRun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasRun: %w", err)
	}
	return oldValue.HasRun, nil
}

// ResetHasRun resets all changes to the "has_run" field.
func (m *TaskMutation) ResetHasRun() {
	m.has_run = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetImplantID sets the "implant" edge to the Implant entity by id.
func (m *TaskMutation) SetImplantID(id int) {
	m.implant = &id
}

// ClearImplant clears the "implant" edge to the Implant entity.
func (m *TaskMutation) ClearImplant() {
	m.clearedimplant = true
}

// ImplantCleared reports if the "implant" edge to the Implant entity was cleared.
func (m *TaskMutation) ImplantCleared() bool {
	return m.clearedimplant
}

// ImplantID returns the "implant" edge ID in the mutation.
func (m *TaskMutation) ImplantID() (id int, exists bool) {
	if m.implant != nil {
		return *m.implant, true
	}
	return
}

// ImplantIDs returns the "implant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImplantID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ImplantIDs() (ids []int) {
	if id := m.implant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImplant resets all changes to the "implant" edge.
func (m *TaskMutation) ResetImplant() {
	m.implant = nil
	m.clearedimplant = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, task.FieldUUID)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.payload != nil {
		fields = append(fields, task.FieldPayload)
	}
	if m.stdout != nil {
		fields = append(fields, task.FieldStdout)
	}
	if m.stderr != nil {
		fields = append(fields, task.FieldStderr)
	}
	if m.has_run != nil {
		fields = append(fields, task.FieldHasRun)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldUUID:
		return m.UUID()
	case task.FieldType:
		return m.GetType()
	case task.FieldPayload:
		return m.Payload()
	case task.FieldStdout:
		return m.Stdout()
	case task.FieldStderr:
		return m.Stderr()
	case task.FieldHasRun:
		return m.HasRun()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldUUID:
		return m.OldUUID(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldPayload:
		return m.OldPayload(ctx)
	case task.FieldStdout:
		return m.OldStdout(ctx)
	case task.FieldStderr:
		return m.OldStderr(ctx)
	case task.FieldHasRun:
		return m.OldHasRun(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case task.FieldType:
		v, ok := value.(task.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case task.FieldStdout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdout(v)
		return nil
	case task.FieldStderr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderr(v)
		return nil
	case task.FieldHasRun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasRun(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldUUID:
		m.ResetUUID()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldPayload:
		m.ResetPayload()
		return nil
	case task.FieldStdout:
		m.ResetStdout()
		return nil
	case task.FieldStderr:
		m.ResetStderr()
		return nil
	case task.FieldHasRun:
		m.ResetHasRun()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.implant != nil {
		edges = append(edges, task.EdgeImplant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeImplant:
		if id := m.implant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimplant {
		edges = append(edges, task.EdgeImplant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeImplant:
		return m.clearedimplant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeImplant:
		m.ClearImplant()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeImplant:
		m.ResetImplant()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
